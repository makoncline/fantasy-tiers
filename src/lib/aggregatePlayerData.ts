import fs from "fs";
import path from "path";
import { z } from "zod";
import { normalizePlayerName } from "./util";
import {
  PlayerWithRankingsSchema,
  RankTierSchema,
  ScoringType,
} from "./schemas";
import { POSITIONS_TO_SCORING_TYPES, RANKINGS_DIR } from "./fetchRankingData";
import { FLEX_POSITIONS } from "./draftHelpers";
import { SleeperProjectionSchema } from "./sleeper";
// Input files (generated by scripts)
const SLEEPER_PROJECTIONS_LATEST = path.resolve(
  process.cwd(),
  "public/data/sleeper/projections-latest.json"
);
const FANTASYPROS_AGGREGATE = path.resolve(
  process.cwd(),
  "public/data/fantasypros/fantasypros_aggregate.json"
);

export const AGGREGATE_DATA_DIR = path.resolve(process.cwd(), "public/data");

// Add this function to get the aggregate data file path based on position
export function getAggregateDataFilePath(position: string): string {
  return path.join(AGGREGATE_DATA_DIR, `${position}-aggregate-players.json`);
}

function ensureDirectoryExists(dirPath: string) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

// Function to aggregate all parsed data into the final player data
function aggregatePlayerData() {
  console.log("All positions:", Object.keys(POSITIONS_TO_SCORING_TYPES));

  // Load Sleepers season projections (season aggregate by default)
  if (!fs.existsSync(SLEEPER_PROJECTIONS_LATEST)) {
    throw new Error(
      `Missing projections file: ${SLEEPER_PROJECTIONS_LATEST}. Run pnpm run fetch:sleeper:projections first.`
    );
  }
  const rawProjections = JSON.parse(
    fs.readFileSync(SLEEPER_PROJECTIONS_LATEST, "utf-8")
  );
  const projections = z
    .array(SleeperProjectionSchema)
    .parse(Array.isArray(rawProjections) ? rawProjections : []);

  // Load FantasyPros aggregate for team and bye mapping
  if (!fs.existsSync(FANTASYPROS_AGGREGATE)) {
    throw new Error(
      `Missing FantasyPros aggregate file: ${FANTASYPROS_AGGREGATE}. Ensure it is generated/available.`
    );
  }
  const fpArrayRaw = JSON.parse(
    fs.readFileSync(FANTASYPROS_AGGREGATE, "utf-8")
  );
  const FpSchema = z.array(
    z.object({
      player_name: z.string(),
      player_positions: z.string(),
      player_team_id: z.string().nullable().optional(),
      player_bye_week: z.string().nullable().optional(),
    })
  );
  const fpArray = FpSchema.parse(fpArrayRaw);
  const fpByName = fpArray.reduce((acc, row) => {
    const norm = normalizePlayerName(row.player_name);
    acc[norm] = {
      team: row.player_team_id ?? null,
      bye_week: row.player_bye_week ?? null,
      position: row.player_positions,
    } as { team: string | null; bye_week: string | null; position: string };
    return acc;
  }, {} as Record<string, { team: string | null; bye_week: string | null; position: string }>);

  // Build a unique set of players from projections keyed by player_id
  const playerData = projections.reduce((acc, p) => {
    const id = p.player_id;
    if (!id) return acc;
    if (acc[id]) return acc;
    const first = p.player.first_name ?? "";
    const last = p.player.last_name ?? "";
    const fullName = `${first} ${last}`.trim();
    const normalizedName = normalizePlayerName(fullName);
    acc[id] = {
      player_id: id,
      name: normalizedName,
      position: (p.player.position ?? "") as any,
      team: p.player.team ?? null,
    };
    return acc;
  }, {} as Record<string, { player_id: string; name: string; position: string; team: string | null }>);

  Object.entries(POSITIONS_TO_SCORING_TYPES).forEach(
    ([position, scoringTypes]) => {
      console.log(`Starting to process position: ${position}`);

      if (position === "undefined" || !position) {
        console.error("Invalid position encountered:", position);
        return; // Skip this iteration
      }

      // Load and parse rankings for each scoring type and transform to an object keyed by player name
      const rankingsData: Record<
        ScoringType,
        Record<string, z.infer<typeof RankTierSchema>>
      > = scoringTypes.reduce((acc, scoringType) => {
        const filePath = path.resolve(
          RANKINGS_DIR,
          `${position}-${scoringType}-rankings.json`
        );
        if (!fs.existsSync(filePath)) {
          console.error(
            `Rankings file for ${position} ${scoringType} does not exist.`
          );
          return acc;
        }
        const parsedRankings = z
          .array(
            z.object({
              rank: z.number(),
              tier: z.number(),
              name: z.string(),
            })
          )
          .parse(JSON.parse(fs.readFileSync(filePath, "utf-8")));

        // Convert array to an object keyed by normalized player name
        const rankingsByPlayerName = parsedRankings.reduce(
          (nameAcc, playerRanking) => {
            const normalizedName = normalizePlayerName(playerRanking.name);
            nameAcc[normalizedName] = {
              rank: playerRanking.rank,
              tier: playerRanking.tier,
            };
            return nameAcc;
          },
          {} as Record<string, z.infer<typeof RankTierSchema>>
        );

        acc[scoringType] = rankingsByPlayerName;
        return acc;
      }, {} as Record<ScoringType, Record<string, z.infer<typeof RankTierSchema>>>);

      console.log(`Processing ${position}`);

      const finalPlayerData: Record<
        string,
        z.infer<typeof PlayerWithRankingsSchema>
      > = {};

      let playerCount = 0;

      // Process all unique players inferred from projections
      Object.values(playerData).forEach((player) => {
        if (position === "ALL") {
          // No filtering for ALL
        } else if (position === "FLEX") {
          if (!FLEX_POSITIONS.includes(player.position as any)) {
            return;
          }
        } else {
          if (player.position !== position) {
            return;
          }
        }

        playerCount++;

        const playerName = normalizePlayerName(player.name);

        // Build the rankings by scoring type
        const rankingsByScoringType = {
          std: scoringTypes.includes("std")
            ? rankingsData.std?.[playerName] || null
            : null,
          ppr: scoringTypes.includes("ppr")
            ? rankingsData.ppr?.[playerName] || null
            : null,
          half: scoringTypes.includes("half")
            ? rankingsData.half?.[playerName] || null
            : null,
        };

        // Assemble the final player object
        const fp = fpByName[playerName] ?? null;
        const byeWeekStr = fp?.bye_week ?? null;
        const teamFromFp = fp?.team ?? player.team;

        const finalPlayer: z.infer<typeof PlayerWithRankingsSchema> = {
          player_id: player.player_id,
          name: player.name,
          position: player.position,
          team: teamFromFp,
          bye_week: byeWeekStr,
          rankingsByScoringType,
        };

        finalPlayerData[finalPlayer.player_id] =
          PlayerWithRankingsSchema.parse(finalPlayer);
      });

      console.log(`Processed ${playerCount} players for ${position}`);

      // Ensure the directory exists before writing the file
      ensureDirectoryExists(AGGREGATE_DATA_DIR);

      // Update this part to use the new function
      const outputFilePath = getAggregateDataFilePath(position);
      console.log(
        `Writing aggregate data for position: ${position} to ${outputFilePath}`
      );

      fs.writeFileSync(
        outputFilePath,
        JSON.stringify(finalPlayerData, null, 2)
      );
      console.log(
        `aggregated ${position} player data saved to ${outputFilePath}\n`
      );
    }
  );
}

// Run the aggregation if this file is executed directly
if (require.main === module) {
  aggregatePlayerData();
}
